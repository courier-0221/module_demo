// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/Regist.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/async/TAsyncProtocolProcessor.h>
#include <thrift/async/TEvhttpServer.h>
#include <event.h>
#include <evhttp.h>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;

using namespace  ::vnmp;

class RegistHandler : virtual public RegistIf {
 public:
  RegistHandler() {
    // Your initialization goes here
  }

  RegistResult::type registClient(const ClientInfo& clientInfo) {
    // Your implementation goes here
    printf("registClient\n");
    printf("recv name.%s realIP.%s vpnIP.%s type.%d description.%s\n", 
        clientInfo.name.c_str(), clientInfo.realIP.c_str(), clientInfo.vpnIP.c_str(), clientInfo.type, clientInfo.description.c_str());
    
    // sleep 5s 模拟服务端处理时间
    printf("registClient start process\n");
    sleep(5);
    printf("registClient end process\n");

    printf("send return value=%d\n", RegistResult::SUCCESS);
    return RegistResult::SUCCESS;
  }

  bool heartbeat(const std::string& name, const ClientType::type type) {
    // Your implementation goes here
    printf("heartbeat\n");
    printf("recv name.%s type.%d\n", name.c_str(), type);

    // sleep 3s 模拟服务端处理时间
    printf("heartbeat start process\n");
    sleep(5);
    printf("heartbeat end process\n");

    std::cout << "send return value=" << true << std::endl;
    return true;
  }

};

class RegistAsyncHandler : public RegistCobSvIf {
 public:
  RegistAsyncHandler() {
    syncHandler_ = std::unique_ptr<RegistHandler>(new RegistHandler);
    // Your initialization goes here
  }
  virtual ~RegistAsyncHandler(){}

  void registClient(::std::function<void(RegistResult::type const& _return)> cob, const ClientInfo& clientInfo) {
    RegistResult::type _return = static_cast<RegistResult::type>(0);
    _return = syncHandler_->registClient(clientInfo);
    return cob(_return);
  }

  void heartbeat(::std::function<void(bool const& _return)> cob, const std::string& name, const ClientType::type type) {
    bool _return = false;
    _return = syncHandler_->heartbeat(name, type);
    return cob(_return);
  }

 protected:
  std::unique_ptr<RegistHandler> syncHandler_;
};

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<RegistAsyncHandler> handler(new RegistAsyncHandler());
  ::std::shared_ptr<RegistAsyncProcessor> processor(new RegistAsyncProcessor(handler));
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  ::std::shared_ptr<TAsyncProtocolProcessor> protocolProcessor(new TAsyncProtocolProcessor(processor, protocolFactory));

  TEvhttpServer server(protocolProcessor, port);
  server.serve();
  return 0;
}

