// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Regist.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TNonblockingServerTransport.h>
#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::vnmp;

class RegistHandler : virtual public RegistIf {
 public:
  RegistHandler() {
    // Your initialization goes here
  }

  RegistResult::type registClient(const ClientInfo& clientInfo) {
    // Your implementation goes here
    printf("registClient\n");
    printf("recv name.%s realIP.%s vpnIP.%s type.%d description.%s\n", 
        clientInfo.name.c_str(), clientInfo.realIP.c_str(), clientInfo.vpnIP.c_str(), clientInfo.type, clientInfo.description.c_str());
    
    // sleep 5s 模拟服务端处理时间
    printf("registClient start process\n");
    sleep(5);
    printf("registClient end process\n");

    printf("send return value=%d\n", RegistResult::SUCCESS);
    return RegistResult::SUCCESS;
  }

  bool heartbeat(const std::string& name, const ClientType::type type) {
    // Your implementation goes here
    printf("heartbeat\n");
    printf("recv name.%s type.%d\n", name.c_str(), type);

    // sleep 3s 模拟服务端处理时间
    printf("heartbeat start process\n");
    sleep(5);
    printf("heartbeat end process\n");

    std::cout << "send return value=" << true << std::endl;
    return true;
  }

};

int main(int argc, char **argv) {

  int port = 9090;
  ::std::shared_ptr<RegistHandler> handler(new RegistHandler());
  ::std::shared_ptr<TProcessor> processor(new RegistProcessor(handler));
  ::std::shared_ptr<TNonblockingServerTransport> serverTransport(new TNonblockingServerSocket(port));
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  ::std::shared_ptr<ThreadFactory> threadFactory(new ThreadFactory());
  ::std::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(10);

  threadManager->threadFactory(threadFactory);
  threadManager->start();

  ::std::shared_ptr<TNonblockingServer> server(new TNonblockingServer(processor, protocolFactory, serverTransport, threadManager));

  server->serve();
  return 0;
}

